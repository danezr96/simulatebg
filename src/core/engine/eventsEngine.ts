// src/core/engine/eventsEngine.ts
import type {
  PendingEvent,
  EventType,
  EventScope,
  WorldId,
  Year,
  WeekNumber,
  WorldEconomyState,
  Sector,
  WorldSectorState,
  Company,
  CompanyFinancials,
  Holding,
 
} from "../domain";

import { asDecimal } from "../domain";
import { clamp, mulberry32 } from "../../utils/math";
import { economyConfig } from "../../config/economy";

/**
 * EventsEngine (v0)
 * - Creates stochastic events each week on WORLD / SECTOR / COMPANY / HOLDING scope
 * - Uses seeded RNG for determinism: (worldId, year, week, "scopeKey")
 *
 * Output:
 * - List of PendingEvent to persist into events table
 */

// Domain doesn't export Season (only SeasonId). We only need eventProbabilities + macroModifiers.
type SeasonLike = {
  eventProbabilities?: {
    globalCrisisChance?: number;
    sectorCrisisBaseChance?: number;
    companyEventBaseChance?: number;
    holdingEventChance?: number;
    sectorCrisisChanceBySector?: Record<string, number>;
    maxCompanyEventsPerWeek?: number;
    companyPositiveBias?: number;
    companyNegativeBias?: number;
  };
  macroModifiers?: {
    // keep room for future
  };
} | null;

export type EventsTickInput = {
  worldId: WorldId;
  year: Year;
  week: WeekNumber;

  economy: WorldEconomyState;
  season?: SeasonLike;

  sectors: Sector[];
  sectorStatesById: Record<string, WorldSectorState | null>;

  companies: Company[];
  companyFinancialsById: Record<string, CompanyFinancials | null>;

  holding: Holding;
};

export type EventsTickOutput = {
  events: PendingEvent[];
};

function seed(worldId: string, year: number, week: number, key: string): number {
  let h = 2166136261;
  const s = `${worldId}|${year}|${week}|${key}`;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function pick<T>(rng: () => number, arr: T[]): T | null {
  if (arr.length === 0) return null;
  const idx = Math.floor(rng() * arr.length);
  return arr[idx] ?? null;
}

function severityRoll(rng: () => number) {
  // skew > 1 biases toward lower values
  const { min, max, skew } = economyConfig.events.severity;
  const x = Math.pow(rng(), skew);
  const s = min + (max - min) * x;
  return clamp(s, min, max);
}

// TEMP helper: your domain uses branded Decimal.
// Ideally you have a factory like decimal(n) in domain/common.
// For now: cast to Decimal.


export const eventsEngine = {
  generate(input: EventsTickInput): EventsTickOutput {
    const cfg = economyConfig.events;

    // Optional season overrides
    const seasonProb = (input.season?.eventProbabilities ?? {}) as any;

    const globalCrisisChance = clamp(
      Number(seasonProb.globalCrisisChance ?? cfg.globalCrisisChance),
      0,
      1
    );

    const sectorCrisisBaseChance = clamp(
      Number(seasonProb.sectorCrisisBaseChance ?? cfg.sectorCrisisBaseChance),
      0,
      1
    );

    const companyEventBaseChance = clamp(
      Number(seasonProb.companyEventBaseChance ?? cfg.companyEventBaseChance),
      0,
      1
    );

    // Optional extra knobs (season-only, with sane defaults)
    const holdingEventChance = clamp(Number(seasonProb.holdingEventChance ?? 0.01), 0, 1);
    const maxCompanyEventsPerWeek = Math.max(0, Number(seasonProb.maxCompanyEventsPerWeek ?? 6));
    const companyPositiveBias = Number(seasonProb.companyPositiveBias ?? 0.03);
    const companyNegativeBias = Number(seasonProb.companyNegativeBias ?? 0.04);
    const sectorCrisisChanceBySector: Record<string, number> =
      (seasonProb.sectorCrisisChanceBySector ?? {}) as any;

    const events: PendingEvent[] = [];

    /* =========================
     * WORLD events
     * ========================= */
    {
      const rng = mulberry32(seed(String(input.worldId), Number(input.year), Number(input.week), "WORLD"));
      if (rng() < globalCrisisChance) {
        const sev = severityRoll(rng);

        const types: EventType[] = ["MACRO_SHOCK", "GLOBAL_CRISIS", "MARKET_PANIC"] as any;
        const type = pick(rng, types) ?? ("GLOBAL_CRISIS" as any);

        events.push({
          worldId: input.worldId,
          scope: "WORLD" as EventScope,
          type,
          severity: asDecimal(sev),
          payload: {
            note: "World-level shock generated by eventsEngine.",
            macroHint: {
              demandGlobalFactor: clamp(1 - 0.15 * sev, 0.5, 1),
              riskGlobalFactor: clamp(1 + 0.25 * sev, 1, 2),
            },
          },
          year: input.year,
          week: input.week,
        });
      }
    }

    /* =========================
     * SECTOR events
     * ========================= */
    for (const sector of input.sectors) {
      const sKey = `SECTOR:${sector.id}`;
      const rng = mulberry32(seed(String(input.worldId), Number(input.year), Number(input.week), sKey));

      const baseChance = clamp(
        Number(sectorCrisisChanceBySector[String(sector.id)] ?? sectorCrisisBaseChance),
        0,
        1
      );

      // small volatility boost if available
      const st = input.sectorStatesById[String(sector.id)];
      const vol = Number(st?.volatility ?? 0.1);
      const volBoost = clamp((vol - 0.1) * 0.6, 0, 0.15);

      if (rng() < baseChance + volBoost) {
        const sev = severityRoll(rng);

        const upOrDown = rng() < 0.5 ? "BOOST" : "CRASH";
        const type: EventType =
          upOrDown === "BOOST" ? ("SECTOR_BOOST" as any) : ("SECTOR_CRASH" as any);

        events.push({
          worldId: input.worldId,
          sectorId: sector.id as any,
          scope: "SECTOR" as EventScope,
          type,
          severity: asDecimal(sev),
          payload: {
            note: "Sector event generated by eventsEngine.",
            effectHint: {
              demandFactor: upOrDown === "BOOST" ? 1 + 0.2 * sev : 1 - 0.2 * sev,
              costFactor: upOrDown === "BOOST" ? 1 : 1 + 0.1 * sev,
              volatilityFactor: 1 + 0.2 * sev,
            },
          },
          year: input.year,
          week: input.week,
        });
      }
    }

    /* =========================
     * COMPANY events
     * ========================= */
    {
      const candidates = input.companies.filter((c) => (c as any).status === "ACTIVE" || !(c as any).status);
      const rng = mulberry32(seed(String(input.worldId), Number(input.year), Number(input.week), "COMPANY_BATCH"));

      let created = 0;

      for (const c of candidates) {
        if (created >= maxCompanyEventsPerWeek) break;

        const fin = input.companyFinancialsById[String(c.id)];
        const profit = Number(fin?.netProfit ?? 0);

        const bias = profit > 0 ? companyPositiveBias : companyNegativeBias;
        const chance = clamp(companyEventBaseChance + bias, 0, 0.6);

        if (rng() < chance) {
          const sev = severityRoll(rng);

          const isPositive = rng() < (profit > 0 ? 0.6 : 0.35);
          const type: EventType = isPositive
            ? (pick(rng, ["COMPANY_PR_AWARD", "INNOVATION_BOOST", "LOCAL_HYPE"] as any) ?? ("COMPANY_PR_AWARD" as any))
            : (pick(rng, ["COMPANY_FINE", "COMPANY_STRIKE", "SUPPLY_SHOCK"] as any) ?? ("COMPANY_FINE" as any));

          events.push({
            worldId: input.worldId,
            companyId: c.id as any,
            scope: "COMPANY" as EventScope,
            type,
            severity: asDecimal(sev),
            payload: {
              note: "Company event generated by eventsEngine.",
              effectHint: isPositive
                ? { reputationDelta: 0.02 * sev, qualityBoost: 0.01 * sev }
                : { cashPenalty: 100 * sev, reputationDelta: -0.03 * sev, costSpike: 0.05 * sev },
            },
            year: input.year,
            week: input.week,
          });

          created += 1;
        }
      }
    }

    /* =========================
     * HOLDING events (rare)
     * ========================= */
    {
      const rng = mulberry32(seed(String(input.worldId), Number(input.year), Number(input.week), "HOLDING"));
      if (rng() < holdingEventChance) {
        const sev = severityRoll(rng);
        const type: EventType = rng() < 0.5 ? ("BANK_REVIEW" as any) : ("HOLDING_PRIZE" as any);

        events.push({
          worldId: input.worldId,
          holdingId: input.holding.id as any,
          scope: "HOLDING" as EventScope,
          type,
          severity: asDecimal(sev),
          payload: {
            note: "Holding event generated by eventsEngine.",
            effectHint: type === ("BANK_REVIEW" as any) ? { loanRateDelta: 0.002 * sev } : { reputationDelta: 0.01 * sev },
          },
          year: input.year,
          week: input.week,
        });
      }
    }

    return { events };
  },
};
